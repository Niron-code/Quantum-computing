# -*- coding: utf-8 -*-
"""Deutsch_Jozsa.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ciaWzSLvvnin-XDIRSdD5-QBjGMRdQjI
"""

import cirq
import numpy as np

# Define your 8x8 oracle matrix from the diagram
oracle_matrix = np.array([
    [0,1,0,0,0,0,0,0],  # |000> -> |001>
    [1,0,0,0,0,0,0,0],  # |001> -> |000>
    [0,0,0,1,0,0,0,0],  # |010> -> |011>
    [0,0,1,0,0,0,0,0],  # |011> -> |010>
    [0,0,0,0,0,1,0,0],  # |100> -> |101>
    [0,0,0,0,1,0,0,0],  # |101> -> |100>
    [0,0,0,0,0,0,0,1],  # |110> -> |111>
    [0,0,0,0,0,0,1,0],  # |111> -> |110>
])

# Build Deutsch–Jozsa circuit for 2 input qubits + 1 output qubit
def deutsch_jozsa(oracle_gate):
    qubits = cirq.LineQubit.range(3)  # q0,q1=input; q2=output
    circuit = cirq.Circuit()

    # Step 1: prepare |00...1>
    circuit.append(cirq.X(qubits[2]))

    # Step 2: apply Hadamards
    circuit.append(cirq.H.on_each(*qubits))

    # Step 3: oracle
    circuit.append(oracle_gate(*qubits))

    # Step 4: Hadamards on input qubits only
    circuit.append(cirq.H(qubits[0]))
    circuit.append(cirq.H(qubits[1]))

    # Step 5: measure input qubits
    circuit.append(cirq.measure(qubits[0], qubits[1], key="result"))

    return circuit, qubits

# Create oracle gate
oracle_gate = cirq.MatrixGate(oracle_matrix)

# Build circuit
circuit, qubits = deutsch_jozsa(oracle_gate)

# Simulate
sim = cirq.Simulator()

# Statevector before measurement
state = sim.simulate(circuit[:-1]).final_state_vector
print("Final statevector (before measurement):")
for i, amp in enumerate(state):
    if abs(amp) > 1e-6:  # only print nonzero
        print(f"|{i:03b}>: {amp}")

# Run measurements
result = sim.run(circuit, repetitions=10)
outcomes = result.measurements["result"].tolist()
print("\nMeasurement outcomes:", outcomes)

# Decide constant/balanced
function_type = "constant" if all(np.array_equal(o, [0,0]) for o in outcomes) else "balanced"
print("Function type:", function_type)

print("\nCircuit:\n", circuit)

import cirq
import numpy as np

# Function to build Deutsch–Jozsa oracle matrix for n=2 inputs + 1 output
def build_dj_oracle_matrix(f_values):
    """
    f_values: list of length 4 with f(00), f(01), f(10), f(11)
              each must be 0 or 1
    Returns: 8x8 numpy array (oracle matrix)
    """
    if len(f_values) != 4 or any(v not in [0,1] for v in f_values):
        raise ValueError("Input must be list [f(00), f(01), f(10), f(11)] with 0/1 values")

    # Basis ordering: |000>,|001>,|010>,|011>,|100>,|101>,|110>,|111>
    basis = [(0,0,0),(0,0,1),(0,1,0),(0,1,1),
             (1,0,0),(1,0,1),(1,1,0),(1,1,1)]
    matrix = np.zeros((8,8), dtype=int)

    for idx,(x1,x2,y) in enumerate(basis):
        f_out = f_values[x1*2 + x2]  # index: 00->0, 01->1, 10->2, 11->3
        new_y = y ^ f_out            # y ⊕ f(x1x2)
        new_state = (x1,x2,new_y)
        new_idx = basis.index(new_state)
        matrix[new_idx, idx] = 1
    return matrix

# Deutsch–Jozsa algorithm
def deutsch_jozsa(oracle_gate):
    # 3 qubits: q0,q1=input; q2=output
    qubits = cirq.LineQubit.range(3)
    circuit = cirq.Circuit()

    # Step 1: prepare |001>
    circuit.append(cirq.X(qubits[2]))

    # Step 2: Hadamards on all qubits
    circuit.append(cirq.H.on_each(*qubits))

    # Step 3: oracle
    circuit.append(oracle_gate(*qubits))

    # Step 4: Hadamards on input qubits only
    circuit.append(cirq.H(qubits[0]))
    circuit.append(cirq.H(qubits[1]))

    # Step 5: measure input qubits
    circuit.append(cirq.measure(qubits[0], qubits[1], key="result"))

    return circuit, qubits

# --- MAIN EXECUTION ---
# Example: f(x1x2) = x1 → [0,0,1,1]
f_values = [0,0,1,1]
oracle_matrix = build_dj_oracle_matrix(f_values)
oracle_gate = cirq.MatrixGate(oracle_matrix)

circuit, qubits = deutsch_jozsa(oracle_gate)
sim = cirq.Simulator()

# Print Oracle Matrix
print("Oracle matrix:\n", oracle_matrix)

# Statevector before measurement
state = sim.simulate(circuit[:-1]).final_state_vector
print("\nFinal statevector (before measurement):")
for i, amp in enumerate(state):
    if abs(amp) > 1e-6:  # only show non-zero amplitudes
        print(f"|{i:03b}>: {amp}")

# Run simulation with measurement
result = sim.run(circuit, repetitions=10)
outcomes = result.measurements["result"].tolist()
print("\nMeasurement outcomes:", outcomes)

# Determine constant vs balanced
function_type = "constant" if all(np.array_equal(o, [0,0]) for o in outcomes) else "balanced"
print("Function type:", function_type)

# Print circuit
print("\nCircuit:\n", circuit)

import cirq
import numpy as np

# ---------------------------
# Input & Oracle Construction
# ---------------------------

def input_f_values():
    """
    Ask user for the truth table f(00), f(01), f(10), f(11).
    Returns a list of four ints [0/1, 0/1, 0/1, 0/1].
    """
    print("Enter f(00), f(01), f(10), f(11) as four comma-separated 0/1 values.")
    raw = input().strip()
    vals = [int(x) for x in raw.split(",")]
    if len(vals) != 4 or any(v not in (0, 1) for v in vals):
        raise ValueError("Please enter exactly four values, each 0 or 1. Example: 0,0,1,1")
    return vals

def build_dj_oracle_matrix_n2(f_values):
    """
    Build 8x8 permutation matrix for n=2 inputs + 1 output.
    Basis order: |000>,|001>,|010>,|011>,|100>,|101>,|110>,|111>
    Oracle: |x, y> -> |x, y ⊕ f(x)>
    where x in {00,01,10,11} and y in {0,1}.
    f_values is [f(00), f(01), f(10), f(11)].
    """
    if len(f_values) != 4 or any(v not in (0, 1) for v in f_values):
        raise ValueError("f_values must be [f(00), f(01), f(10), f(11)] with 0/1 entries")

    # Map basis index -> (x1,x2,y)
    basis = [(0,0,0),(0,0,1),(0,1,0),(0,1,1),
             (1,0,0),(1,0,1),(1,1,0),(1,1,1)]
    U = np.zeros((8, 8), dtype=int)

    for col_idx, (x1, x2, y) in enumerate(basis):
        # Index for x = (x1x2) in order 00->0, 01->1, 10->2, 11->3
        x_index = x1 * 2 + x2
        new_y = y ^ f_values[x_index]
        row_idx = basis.index((x1, x2, new_y))
        U[row_idx, col_idx] = 1  # permutation
    return U

# ---------------------------
# Deutsch–Jozsa Circuit (n=2)
# ---------------------------

def deutsch_jozsa_circuit_n2(oracle_gate):
    """Build DJ circuit for 2 input qubits + 1 output qubit."""
    q = cirq.LineQubit.range(3)      # q0,q1 inputs; q2 output
    x_qubits = q[:2]
    y_qubit  = q[2]

    circuit = cirq.Circuit()
    # |001>
    circuit.append(cirq.X(y_qubit))
    # H on all three
    circuit.append(cirq.H.on_each(*q))
    # Oracle
    circuit.append(oracle_gate(*q))
    # H on input qubits only
    circuit.append(cirq.H.on_each(*x_qubits))
    # Measure input qubits as one register (key="result")
    circuit.append(cirq.measure(*x_qubits, key="result"))
    return circuit

def print_statevector_labeled(state):
    """Pretty-print only non-zero amplitudes with |x1x2,y> labels."""
    basis_labels = [f"|{i>>2:02b}{(i>>1)&1},{i&1}>" for i in range(8)]
    for i, amp in enumerate(state):
        if abs(amp) > 1e-8:
            print(f"{basis_labels[i]}: {amp}")

# ---------------------------
# Main
# ---------------------------

if __name__ == "__main__":
    # 1) Get f-values from user and build oracle
    f_values = input_f_values()  # e.g., 0,0,1,1 for f(x1x2)=x1
    U_f = build_dj_oracle_matrix_n2(f_values)
    oracle_gate = cirq.MatrixGate(U_f)

    # 2) Build circuit
    circuit = deutsch_jozsa_circuit_n2(oracle_gate)
    print("Oracle matrix U_f:\n", U_f)

    # 3) Statevector before measurement
    sim = cirq.Simulator()
    sv = sim.simulate(circuit[:-1]).final_state_vector
    print("\nFinal statevector (before measurement):")
    print_statevector_labeled(sv)

    # 4) Run with measurement
    reps = 10
    result = sim.run(circuit, repetitions=reps)
    # result.measurements["result"] is shape (reps, 2) with bits [q0,q1]
    shots = ["".join(map(str, row)) for row in result.measurements["result"]]
    print(f"\nMeasurement outcomes ({reps} shots): {shots}")

    # 5) DJ verdict: constant iff all-zero on input register
    is_constant = all(bits == "00" for bits in shots)
    print("Function type:", "constant" if is_constant else "balanced")

    print("\nCircuit:\n", circuit)